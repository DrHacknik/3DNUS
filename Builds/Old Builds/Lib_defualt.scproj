{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs18 [ext_info]\par
//Extension Information, Privlages, and Code for LIB_SD_Fat\par
//for VNM EMU. \par
//NOTE: The Following Text use's RTF ANSI Format! \par
\par
priv=2\par
ext_external="\\\\_bin","\\\\_res"\par
ext_type=default\par
ext_base_lib="lib_citras","lib_win_fat","lib_3ds","lib_sdfat"\par
ext_base_ver="2.5.4.6; v29376"\par
\par
//Code for Lib_sd_fat:\par
//Code is Lang "H"\par
//SD_FAT.h\par
\par
@SD_FAT.h\par
\par
/* Arduino SdFat Library\par
 * Copyright (C) 2012 by William Greiman\par
 *\par
 * This file is part of the Arduino SdFat Library\par
 *\par
 * This Library is free software: you can redistribute it and/or modify\par
 * it under the terms of the GNU General Public License as published by\par
 * the Free Software Foundation, either version 3 of the License, or\par
 * (at your option) any later version.\par
 *\par
 * This Library is distributed in the hope that it will be useful,\par
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\par
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
 * GNU General Public License for more details.\par
 *\par
 * You should have received a copy of the GNU General Public License\par
 * along with the Arduino SdFat Library.  If not, see\par
 * <http://www.gnu.org/licenses/>.\par
 */\par
#ifndef SdFat_h\par
#define SdFat_h\par
/**\par
 * \\file\par
 * \\brief SdFat class\par
 */\par
#include "SdSpiCard.h"\par
#include "utility/FatLib.h"\par
//------------------------------------------------------------------------------\par
/** SdFat version YYYYMMDD */\par
#define SD_FAT_VERSION 20150324\par
//==============================================================================\par
/**\par
 * \\class SdBaseFile\par
 * \\brief Class for backward compatibility.\par
 */\par
class SdBaseFile : public FatFile \{\par
 public:\par
  SdBaseFile() \{\}\par
  /**  Create a file object and open it in the current working directory.\par
   *\par
   * \\param[in] path A path for a file to be opened.\par
   *\par
   * \\param[in] oflag Values for \\a oflag are constructed by a\par
   * bitwise-inclusive OR of open flags. see\par
   * FatFile::open(FatFile*, const char*, uint8_t).\par
   */\par
  SdBaseFile(const char* path, uint8_t oflag) : FatFile(path, oflag) \{\}\par
\};\par
#if ENABLE_ARDUINO_FEATURES\par
/**\par
 * \\class SdFile\par
 * \\brief Class for backward compatibility.\par
 */\par
\par
class SdFile : public PrintFile \{\par
 public:\par
  SdFile() \{\}\par
  /**  Create a file object and open it in the current working directory.\par
   *\par
   * \\param[in] path A path for a file to be opened.\par
   *\par
   * \\param[in] oflag Values for \\a oflag are constructed by a\par
   * bitwise-inclusive OR of open flags. see\par
   * FatFile::open(FatFile*, const char*, uint8_t).\par
   */\par
  SdFile(const char* path, uint8_t oflag) : PrintFile(path, oflag) \{\}\par
\};\par
#endif  // #if ENABLE_ARDUINO_FEATURES\par
/**\par
 * \\class SdFatBase\par
 * \\brief Virtual base class for %SdFat library.\par
 */\par
class SdFatBase : public FatFileSystem \{\par
 public:\par
  /** Initialize SD card and file system.\par
   * \\param[in] spi SPI object for the card.\par
   * \\param[in] csPin SD card chip select pin.\par
   * \\param[in] divisor SPI divisor.\par
   * \\return true for success else false.\par
   */\par
  bool begin(SdSpiCard::m_spi_t* spi, uint8_t csPin = SS, uint8_t divisor = 2) \{\par
    return m_sdCard.begin(spi, csPin, divisor) &&\par
           FatFileSystem::begin();\par
  \}\par
  /** \\return Pointer to SD card object */\par
  SdSpiCard *card() \{\par
    return &m_sdCard;\par
  \}\par
  /** %Print any SD error code to Serial and halt. */\par
  void errorHalt() \{\par
    errorHalt(&Serial);\par
  \}\par
  /** %Print any SD error code and halt.\par
   *\par
   * \\param[in] pr Print destination.\par
   */\par
  void errorHalt(Print* pr);\par
  /** %Print msg, any SD error code and halt.\par
   *\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorHalt(char const* msg) \{\par
    errorHalt(&Serial, msg);\par
  \}\par
  /** %Print msg, any SD error code, and halt.\par
   *\par
   * \\param[in] pr Print destination.\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorHalt(Print* pr, char const* msg);\par
  /** %Print msg, any SD error code, and halt.\par
   *\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorHalt(const __FlashStringHelper* msg) \{\par
    errorHalt(&Serial, msg);\par
  \}\par
  /** %Print msg, any SD error code, and halt.\par
   *\par
   * \\param[in] pr Print destination.\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorHalt(Print* pr, const __FlashStringHelper* msg);\par
  /** %Print any SD error code to Serial */\par
  void errorPrint() \{\par
    errorPrint(&Serial);\par
  \}\par
  /** %Print any SD error code.\par
   * \\param[in] pr Print device.\par
   */\par
  void errorPrint(Print* pr);\par
  /** %Print msg, any SD error code.\par
   *\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorPrint(const char* msg) \{\par
    errorPrint(&Serial, msg);\par
  \}\par
  /** %Print msg, any SD error code.\par
   *\par
   * \\param[in] pr Print destination.\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorPrint(Print* pr, char const* msg);\par
  /** %Print msg, any SD error code.\par
   *\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorPrint(const __FlashStringHelper* msg) \{\par
    errorPrint(&Serial, msg);\par
  \}\par
  /** %Print msg, any SD error code.\par
   *\par
   * \\param[in] pr Print destination.\par
   * \\param[in] msg Message to print.\par
   */\par
  void errorPrint(Print* pr, const __FlashStringHelper* msg);\par
  /** Diagnostic call to initialize FatFileSystem - use for\par
   *  diagnostic purposes only.\par
   *  \\return true for success else false.\par
   */\par
  bool fsBegin() \{\par
    return FatFileSystem::begin();\par
  \}\par
  /** %Print any SD error code and halt. */\par
  void initErrorHalt() \{\par
    initErrorHalt(&Serial);\par
  \}\par
  /** %Print error details and halt after begin fails.\par
   *\par
   * \\param[in] pr Print destination.\par
   */\par
  void initErrorHalt(Print* pr);\par
  /**Print message, error details, and halt after SdFat::init() fails.\par
   *\par
   * \\param[in] msg Message to print.\par
   */\par
  void initErrorHalt(char const *msg) \{\par
    initErrorHalt(&Serial, msg);\par
  \}\par
  /**Print message, error details, and halt after SdFatBase::init() fails.\par
   * \\param[in] pr Print device.\par
   * \\param[in] msg Message to print.\par
   */\par
  void initErrorHalt(Print* pr, char const *msg);\par
  /**Print message, error details, and halt after SdFat::init() fails.\par
    *\par
    * \\param[in] msg Message to print.\par
    */\par
  void initErrorHalt(const __FlashStringHelper* msg) \{\par
    initErrorHalt(&Serial, msg);\par
  \}\par
  /**Print message, error details, and halt after SdFatBase::init() fails.\par
   * \\param[in] pr Print device for message.\par
   * \\param[in] msg Message to print.\par
   */\par
  void initErrorHalt(Print* pr, const __FlashStringHelper* msg);\par
  /** Print error details after SdFat::init() fails. */\par
  void initErrorPrint() \{\par
    initErrorPrint(&Serial);\par
  \}\par
  /** Print error details after SdFatBase::init() fails.\par
   *\par
   * \\param[in] pr Print destination.\par
   */\par
  void initErrorPrint(Print* pr);\par
  /**Print message and error details and halt after SdFat::init() fails.\par
   *\par
   * \\param[in] msg Message to print.\par
   */\par
  void initErrorPrint(char const *msg) \{\par
    initErrorPrint(&Serial, msg);\par
  \}\par
  /**Print message and error details and halt after SdFatBase::init() fails.\par
   *\par
   * \\param[in] pr Print destination.\par
   * \\param[in] msg Message to print.\par
   */\par
  void initErrorPrint(Print* pr, char const *msg);\par
  /**Print message and error details and halt after SdFat::init() fails.\par
   *\par
   * \\param[in] msg Message to print.\par
   */\par
  void initErrorPrint(const __FlashStringHelper* msg) \{\par
    initErrorPrint(&Serial, msg);\par
  \}\par
  /**Print message and error details and halt after SdFatBase::init() fails.\par
   *\par
   * \\param[in] pr Print destination.\par
   * \\param[in] msg Message to print.\par
   */\par
  void initErrorPrint(Print* pr, const __FlashStringHelper* msg);\par
\par
 private:\par
  uint8_t cardErrorCode() \{\par
    return m_sdCard.errorCode();\par
  \}\par
  uint8_t cardErrorData() \{\par
    return m_sdCard.errorData();\par
  \}\par
  bool readBlock(uint32_t block, uint8_t* dst) \{\par
    return m_sdCard.readBlock(block, dst);\par
  \}\par
  bool writeBlock(uint32_t block, const uint8_t* src) \{\par
    return m_sdCard.writeBlock(block, src);\par
  \}\par
  bool readBlocks(uint32_t block, uint8_t* dst, size_t n) \{\par
    return m_sdCard.readBlocks(block, dst, n);\par
  \}\par
  bool writeBlocks(uint32_t block, const uint8_t* src, size_t n) \{\par
    return m_sdCard.writeBlocks(block, src, n);\par
  \}\par
  SdSpiCard m_sdCard;\par
\};\par
//==============================================================================\par
/**\par
 * \\class SdFat\par
 * \\brief Main file system class for %SdFat library.\par
 */\par
class SdFat : public SdFatBase \{\par
 public:\par
  /** Initialize SD card and file system.\par
   *\par
   * \\param[in] csPin SD card chip select pin.\par
   * \\param[in] divisor SPI divisor.\par
   * \\return true for success else false.\par
   */\par
  bool begin(uint8_t csPin = SS, uint8_t divisor = 2) \{\par
    return SdFatBase::begin(&m_spi, csPin, divisor);\par
  \}\par
  /** Diagnostic call to initialize SD card - use for diagnostic purposes only.\par
   * \\param[in] csPin SD card chip select pin.\par
   * \\param[in] divisor SPI divisor.\par
   * \\return true for success else false.\par
   */\par
  bool cardBegin(uint8_t csPin = SS, uint8_t divisor = 2) \{\par
    return card()->begin(&m_spi, csPin, divisor);\par
  \}\par
 private:\par
  SpiDefault_t m_spi;\par
\};\par
//==============================================================================\par
#if SD_SPI_CONFIGURATION >= 3 || defined(DOXYGEN)\par
/**\par
 * \\class SdFatLibSpi\par
 * \\brief SdFat class using the standard Arduino SPI library.\par
 */\par
class SdFatLibSpi: public SdFatBase \{\par
 public:\par
  /** Initialize SD card and file system.\par
  *\par
  * \\param[in] csPin SD card chip select pin.\par
  * \\param[in] divisor SPI divisor.\par
  * \\return true for success else false.\par
  */\par
  bool begin(uint8_t csPin = SS, uint8_t divisor = 2) \{\par
    return SdFatBase::begin(&m_spi, csPin, divisor);\par
  \}\par
  /** Diagnostic call to initialize SD card - use for diagnostic purposes only.\par
   * \\param[in] csPin SD card chip select pin.\par
   * \\param[in] divisor SPI divisor.\par
   * \\return true for success else false.\par
   */\par
  bool cardBegin(uint8_t csPin = SS, uint8_t divisor = 2) \{\par
    return card()->begin(&m_spi, csPin, divisor);\par
  \}\par
\par
 private:\par
  SdSpiLib m_spi;\par
\};\par
//==============================================================================\par
/**\par
 * \\class SdFatSoftSpi\par
 * \\brief SdFat class using software SPI.\par
 */\par
template<uint8_t MisoPin, uint8_t MosiPin, uint8_t SckPin>\par
class SdFatSoftSpi : public SdFatBase \{\par
 public:\par
  /** Initialize SD card and file system.\par
   *\par
   * \\param[in] csPin SD card chip select pin.\par
   * \\param[in] divisor SPI divisor.\par
   * \\return true for success else false.\par
   */\par
  bool begin(uint8_t csPin = SS, uint8_t divisor = 2) \{\par
    return SdFatBase::begin(&m_spi, csPin, divisor);\par
  \}\par
  /** Diagnostic call to initialize SD card - use for diagnostic purposes only.\par
   * \\param[in] csPin SD card chip select pin.\par
   * \\param[in] divisor SPI divisor.\par
   * \\return true for success else false.\par
   */\par
  bool cardBegin(uint8_t csPin = SS, uint8_t divisor = 2) \{\par
    return card()->begin(&m_spi, csPin, divisor);\par
  \}\par
\par
 private:\par
  SdSpiSoft<MisoPin, MosiPin, SckPin> m_spi;\par
\};\par
#endif  /// SD_SPI_CONFIGURATION >= 3 || defined(DOXYGEN)\par
#endif  // SdFat_h\par
\par
//SDFAT_BASE.cpp: \par
\line @SDFAT_BASE.cpp\par
\par
/* Arduino SdFat Library\par
 * Copyright (C) 2012 by William Greiman\par
 *\par
 * This file is part of the Arduino SdFat Library\par
 *\par
 * This Library is free software: you can redistribute it and/or modify\par
 * it under the terms of the GNU General Public License as published by\par
 * the Free Software Foundation, either version 3 of the License, or\par
 * (at your option) any later version.\par
 *\par
 * This Library is distributed in the hope that it will be useful,\par
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\par
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
 * GNU General Public License for more details.\par
 *\par
 * You should have received a copy of the GNU General Public License\par
 * along with the Arduino SdFat Library.  If not, see\par
 * <http://www.gnu.org/licenses/>.\par
 */\par
#include "SdFat.h"\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorHalt(Print* pr) \{\par
  errorPrint(pr);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorHalt(Print* pr, char const* msg) \{\par
  errorPrint(pr, msg);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorHalt(Print* pr, const __FlashStringHelper* msg) \{\par
  errorPrint(pr, msg);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorPrint(Print* pr) \{\par
  if (!cardErrorCode()) \{\par
    return;\par
  \}\par
  pr->print(F("SD errorCode: 0X"));\par
  pr->print(cardErrorCode(), HEX);\par
  pr->print(F(",0X"));\par
  pr->println(cardErrorData(), HEX);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorPrint(Print* pr, char const* msg) \{\par
  pr->print(F("error: "));\par
  pr->println(msg);\par
  errorPrint(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorPrint(Print* pr, const __FlashStringHelper* msg) \{\par
  pr->print(F("error: "));\par
  pr->println(msg);\par
  errorPrint(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorHalt(Print* pr) \{\par
  initErrorPrint(pr);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorHalt(Print* pr, char const *msg) \{\par
  pr->println(msg);\par
  initErrorHalt(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorHalt(Print* pr, const __FlashStringHelper* msg) \{\par
  pr->println(msg);\par
  initErrorHalt(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorPrint(Print* pr) \{\par
  if (cardErrorCode()) \{\par
    pr->println(F("Can't access SD card. Do not reformat."));\par
    if (cardErrorCode() == SD_CARD_ERROR_CMD0) \{\par
      pr->println(F("No card, wrong chip select pin, or SPI problem?"));\par
    \}\par
    errorPrint(pr);\par
  \} else if (vol()->fatType() == 0) \{\par
    pr->println(F("Invalid format, reformat SD."));\par
  \} else if (!vwd()->isOpen()) \{\par
    pr->println(F("Can't open root directory."));\par
  \} else \{\par
    pr->println(F("No error found."));\par
  \}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorPrint(Print* pr, char const *msg) \{\par
  pr->println(msg);\par
  initErrorPrint(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorPrint(Print* pr, const __FlashStringHelper* msg) \{\par
  pr->println(msg);\par
  initErrorPrint(pr);\par
\}\par
\par
//SDFAT_CONFIG.h: \par
\par
@SDFAT_CONFIG.h\par
\par
/* Arduino SdFat Library\par
 * Copyright (C) 2012 by William Greiman\par
 *\par
 * This file is part of the Arduino SdFat Library\par
 *\par
 * This Library is free software: you can redistribute it and/or modify\par
 * it under the terms of the GNU General Public License as published by\par
 * the Free Software Foundation, either version 3 of the License, or\par
 * (at your option) any later version.\par
 *\par
 * This Library is distributed in the hope that it will be useful,\par
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\par
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
 * GNU General Public License for more details.\par
 *\par
 * You should have received a copy of the GNU General Public License\par
 * along with the Arduino SdFat Library.  If not, see\par
 * <http://www.gnu.org/licenses/>.\par
 */\par
#include "SdFat.h"\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorHalt(Print* pr) \{\par
  errorPrint(pr);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorHalt(Print* pr, char const* msg) \{\par
  errorPrint(pr, msg);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorHalt(Print* pr, const __FlashStringHelper* msg) \{\par
  errorPrint(pr, msg);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorPrint(Print* pr) \{\par
  if (!cardErrorCode()) \{\par
    return;\par
  \}\par
  pr->print(F("SD errorCode: 0X"));\par
  pr->print(cardErrorCode(), HEX);\par
  pr->print(F(",0X"));\par
  pr->println(cardErrorData(), HEX);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorPrint(Print* pr, char const* msg) \{\par
  pr->print(F("error: "));\par
  pr->println(msg);\par
  errorPrint(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::errorPrint(Print* pr, const __FlashStringHelper* msg) \{\par
  pr->print(F("error: "));\par
  pr->println(msg);\par
  errorPrint(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorHalt(Print* pr) \{\par
  initErrorPrint(pr);\par
  while (1) \{\}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorHalt(Print* pr, char const *msg) \{\par
  pr->println(msg);\par
  initErrorHalt(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorHalt(Print* pr, const __FlashStringHelper* msg) \{\par
  pr->println(msg);\par
  initErrorHalt(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorPrint(Print* pr) \{\par
  if (cardErrorCode()) \{\par
    pr->println(F("Can't access SD card. Do not reformat."));\par
    if (cardErrorCode() == SD_CARD_ERROR_CMD0) \{\par
      pr->println(F("No card, wrong chip select pin, or SPI problem?"));\par
    \}\par
    errorPrint(pr);\par
  \} else if (vol()->fatType() == 0) \{\par
    pr->println(F("Invalid format, reformat SD."));\par
  \} else if (!vwd()->isOpen()) \{\par
    pr->println(F("Can't open root directory."));\par
  \} else \{\par
    pr->println(F("No error found."));\par
  \}\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorPrint(Print* pr, char const *msg) \{\par
  pr->println(msg);\par
  initErrorPrint(pr);\par
\}\par
//------------------------------------------------------------------------------\par
void SdFatBase::initErrorPrint(Print* pr, const __FlashStringHelper* msg) \{\par
  pr->println(msg);\par
  initErrorPrint(pr);\par
\}\par
\par
//SDFAT_VOL.h: \par
\par
@SDFAT_VOL.h\par
\par
/* Arduino SdFat Library\par
 * Copyright (C) 2012 by William Greiman\par
 *\par
 * This file is part of the Arduino SdFat Library\par
 *\par
 * This Library is free software: you can redistribute it and/or modify\par
 * it under the terms of the GNU General Public License as published by\par
 * the Free Software Foundation, either version 3 of the License, or\par
 * (at your option) any later version.\par
 *\par
 * This Library is distributed in the hope that it will be useful,\par
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\par
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
 * GNU General Public License for more details.\par
 *\par
 * You should have received a copy of the GNU General Public License\par
 * along with the Arduino SdFat Library.  If not, see\par
 * <http://www.gnu.org/licenses/>.\par
 */\par
#ifndef SdVolume_h\par
#include "SdSpiCard.h"\par
#include "utility/FatLib.h"\par
#define SdVolume_h\par
#ifndef USE_SD_VOLUME\par
#error SdVolume is deperacated.  Remove this line to continue using this class.\par
#endif   // USE_SD_VOLUME\par
//==============================================================================\par
/**\par
 * \\class SdVolume\par
 * \\brief SdVolume Soon to be removed.\par
 */\par
class SdVolume : public FatVolume \{\par
 public:\par
  /** Initialize a FAT volume.  Try partition one first then try super\par
  * floppy format.\par
  *\par
  * \\param[in] dev The Sd2Card where the volume is located.\par
  *\par
  * \\return true for success else false.\par
  */\par
  bool init(Sd2Card* dev) \{\par
    return init(dev, 1) ? true : init(dev, 0);\par
  \}\par
  /** Initialize a FAT volume.\par
  *\par
  * \\param[in] dev The Sd2Card where the volume is located.\par
  * \\param[in] part the partition to use. Zero for super floppy or 1-4.\par
  * \\return true for success else false.\par
  */\par
  bool init(Sd2Card* dev, uint8_t part) \{\par
    m_sdCard = dev;\par
    return FatVolume::init(part);\par
  \}\par
\par
 private:\par
//  friend class FatFile;\par
  bool readBlock(uint32_t block, uint8_t* dst) \{\par
    return m_sdCard->readBlock(block, dst);\par
  \}\par
  bool writeBlock(uint32_t block, const uint8_t* src) \{\par
    return m_sdCard->writeBlock(block, src);\par
  \}\par
  bool readBlocks(uint32_t block, uint8_t* dst, size_t n) \{\par
    return m_sdCard->readBlocks(block, dst, n);\par
  \}\par
  bool writeBlocks(uint32_t block, const uint8_t* src, size_t n) \{\par
    return m_sdCard->writeBlocks(block, src, n);\par
  \}\par
  Sd2Card* m_sdCard;             // Sd2Card object for cache\par
\};\par
#endif  // SdVolume_h\par
\par
//SDFAT_UTIL.h: \par
\par
@SDFAT_UTIL.h\par
\par
/* Arduino SdFat Library\par
 * Copyright (C) 2012 by William Greiman\par
 *\par
 * This file is part of the Arduino SdFat Library\par
 *\par
 * This Library is free software: you can redistribute it and/or modify\par
 * it under the terms of the GNU General Public License as published by\par
 * the Free Software Foundation, either version 3 of the License, or\par
 * (at your option) any later version.\par
 *\par
 * This Library is distributed in the hope that it will be useful,\par
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\par
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
 * GNU General Public License for more details.\par
 *\par
 * You should have received a copy of the GNU General Public License\par
 * along with the Arduino SdFat Library.  If not, see\par
 * <http://www.gnu.org/licenses/>.\par
 */\par
#ifndef SdFatUtil_h\par
#define SdFatUtil_h\par
/**\par
 * \\file\par
 * \\brief Useful utility functions.\par
 */\par
#include "SdFat.h"\par
/** Store and print a string in flash memory.*/\par
#define PgmPrint(x) SerialPrint_P(PSTR(x))\par
/** Store and print a string in flash memory followed by a CR/LF.*/\par
#define PgmPrintln(x) SerialPrintln_P(PSTR(x))\par
\par
namespace SdFatUtil \{\par
  /** Amount of free RAM\par
   * \\return The number of free bytes.\par
   */\par
  int FreeRam();\par
  /** %Print a string in flash memory.\par
   *\par
   * \\param[in] pr Print object for output.\par
   * \\param[in] str Pointer to string stored in flash memory.\par
   */\par
  void print_P(Print* pr, PGM_P str);\par
  /** %Print a string in flash memory followed by a CR/LF.\par
   *\par
   * \\param[in] pr Print object for output.\par
   * \\param[in] str Pointer to string stored in flash memory.\par
   */\par
  void println_P(Print* pr, PGM_P str);\par
  //----------------------------------------------------------------------------\par
  /** %Print a string in flash memory to Serial.\par
   *\par
   * \\param[in] str Pointer to string stored in flash memory.\par
   */\par
  inline void SerialPrint_P(PGM_P str) \{\par
    print_P(&Serial, str);\par
  \}\par
  //----------------------------------------------------------------------------\par
  /** %Print a string in flash memory to Serial followed by a CR/LF.\par
   *\par
   * \\param[in] str Pointer to string stored in flash memory.\par
   */\par
  inline void SerialPrintln_P(PGM_P str) \{\par
    println_P(&Serial, str);\par
  \}\par
\}  // namespace SdFatUtil\par
using namespace SdFatUtil;  // NOLINT\par
#endif  // #define SdFatUtil_h\par
\par
//SD_INFO.h: \par
\par
@SD_INFO.h\par
\par
/* Arduino SdSpiCard Library\par
 * Copyright (C) 2012 by William Greiman\par
 *\par
 * This file is part of the Arduino SdSpiCard Library\par
 *\par
 * This Library is free software: you can redistribute it and/or modify\par
 * it under the terms of the GNU General Public License as published by\par
 * the Free Software Foundation, either version 3 of the License, or\par
 * (at your option) any later version.\par
 *\par
 * This Library is distributed in the hope that it will be useful,\par
 * but WITHOUT ANY WARRANTY; without even the implied warranty of\par
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
 * GNU General Public License for more details.\par
 *\par
 * You should have received a copy of the GNU General Public License\par
 * along with the Arduino SdSpiCard Library.  If not, see\par
 * <http://www.gnu.org/licenses/>.\par
 */\par
#ifndef SdInfo_h\par
#define SdInfo_h\par
#include <stdint.h>\par
// Based on the document:\par
//\par
// SD Specifications\par
// Part 1\par
// Physical Layer\par
// Simplified Specification\par
// Version 3.01\par
// May 18, 2010\par
//\par
// http://www.sdcard.org/developers/tech/sdcard/pls/simplified_specs\par
//------------------------------------------------------------------------------\par
// SD card errors\par
/** timeout error for command CMD0 (initialize card in SPI mode) */\par
uint8_t const SD_CARD_ERROR_CMD0 = 0X1;\par
/** CMD8 was not accepted - not a valid SD card*/\par
uint8_t const SD_CARD_ERROR_CMD8 = 0X2;\par
/** card returned an error response for CMD12 (stop multiblock read) */\par
uint8_t const SD_CARD_ERROR_CMD12 = 0X3;\par
/** card returned an error response for CMD17 (read block) */\par
uint8_t const SD_CARD_ERROR_CMD17 = 0X4;\par
/** card returned an error response for CMD18 (read multiple block) */\par
uint8_t const SD_CARD_ERROR_CMD18 = 0X5;\par
/** card returned an error response for CMD24 (write block) */\par
uint8_t const SD_CARD_ERROR_CMD24 = 0X6;\par
/**  WRITE_MULTIPLE_BLOCKS command failed */\par
uint8_t const SD_CARD_ERROR_CMD25 = 0X7;\par
/** card returned an error response for CMD58 (read OCR) */\par
uint8_t const SD_CARD_ERROR_CMD58 = 0X8;\par
/** SET_WR_BLK_ERASE_COUNT failed */\par
uint8_t const SD_CARD_ERROR_ACMD23 = 0X9;\par
/** ACMD41 initialization process timeout */\par
uint8_t const SD_CARD_ERROR_ACMD41 = 0XA;\par
/** card returned a bad CSR version field */\par
uint8_t const SD_CARD_ERROR_BAD_CSD = 0XB;\par
/** erase block group command failed */\par
uint8_t const SD_CARD_ERROR_ERASE = 0XC;\par
/** card not capable of single block erase */\par
uint8_t const SD_CARD_ERROR_ERASE_SINGLE_BLOCK = 0XD;\par
/** Erase sequence timed out */\par
uint8_t const SD_CARD_ERROR_ERASE_TIMEOUT = 0XE;\par
/** card returned an error token instead of read data */\par
uint8_t const SD_CARD_ERROR_READ = 0XF;\par
/** read CID or CSD failed */\par
uint8_t const SD_CARD_ERROR_READ_REG = 0X10;\par
/** timeout while waiting for start of read data */\par
uint8_t const SD_CARD_ERROR_READ_TIMEOUT = 0X11;\par
/** card did not accept STOP_TRAN_TOKEN */\par
uint8_t const SD_CARD_ERROR_STOP_TRAN = 0X12;\par
/** card returned an error token as a response to a write operation */\par
uint8_t const SD_CARD_ERROR_WRITE = 0X13;\par
/** attempt to write protected block zero */\par
uint8_t const SD_CARD_ERROR_WRITE_BLOCK_ZERO = 0X14;  // REMOVE - not used\par
/** card did not go ready for a multiple block write */\par
uint8_t const SD_CARD_ERROR_WRITE_MULTIPLE = 0X15;\par
/** card returned an error to a CMD13 status check after a write */\par
uint8_t const SD_CARD_ERROR_WRITE_PROGRAMMING = 0X16;\par
/** timeout occurred during write programming */\par
uint8_t const SD_CARD_ERROR_WRITE_TIMEOUT = 0X17;\par
/** incorrect rate selected */\par
uint8_t const SD_CARD_ERROR_SCK_RATE = 0X18;\par
/** init() not called */\par
uint8_t const SD_CARD_ERROR_INIT_NOT_CALLED = 0X19;\par
/** card returned an error for CMD59 (CRC_ON_OFF) */\par
uint8_t const SD_CARD_ERROR_CMD59 = 0X1A;\par
/** invalid read CRC */\par
uint8_t const SD_CARD_ERROR_READ_CRC = 0X1B;\par
/** SPI DMA error */\par
uint8_t const SD_CARD_ERROR_SPI_DMA = 0X1C;\par
//------------------------------------------------------------------------------\par
// card types\par
/** Standard capacity V1 SD card */\par
uint8_t const SD_CARD_TYPE_SD1  = 1;\par
/** Standard capacity V2 SD card */\par
uint8_t const SD_CARD_TYPE_SD2  = 2;\par
/** High Capacity SD card */\par
uint8_t const SD_CARD_TYPE_SDHC = 3;\par
//------------------------------------------------------------------------------\par
// SPI divisor constants\par
/** Set SCK to max rate of F_CPU/2. */\par
uint8_t const SPI_FULL_SPEED = 2;\par
/** Set SCK rate to F_CPU/3 for Due */\par
uint8_t const SPI_DIV3_SPEED = 3;\par
/** Set SCK rate to F_CPU/4. */\par
uint8_t const SPI_HALF_SPEED = 4;\par
/** Set SCK rate to F_CPU/6 for Due */\par
uint8_t const SPI_DIV6_SPEED = 6;\par
/** Set SCK rate to F_CPU/8. */\par
uint8_t const SPI_QUARTER_SPEED = 8;\par
/** Set SCK rate to F_CPU/16. */\par
uint8_t const SPI_EIGHTH_SPEED = 16;\par
/** Set SCK rate to F_CPU/32. */\par
uint8_t const SPI_SIXTEENTH_SPEED = 32;\par
//------------------------------------------------------------------------------\par
// SD operation timeouts\par
/** init timeout ms */\par
uint16_t const SD_INIT_TIMEOUT = 2000;\par
/** erase timeout ms */\par
uint16_t const SD_ERASE_TIMEOUT = 10000;\par
/** read timeout ms */\par
uint16_t const SD_READ_TIMEOUT = 300;\par
/** write time out ms */\par
uint16_t const SD_WRITE_TIMEOUT = 600;\par
//------------------------------------------------------------------------------\par
// SD card commands\par
/** GO_IDLE_STATE - init card in spi mode if CS low */\par
uint8_t const CMD0 = 0X00;\par
/** SEND_IF_COND - verify SD Memory Card interface operating condition.*/\par
uint8_t const CMD8 = 0X08;\par
/** SEND_CSD - read the Card Specific Data (CSD register) */\par
uint8_t const CMD9 = 0X09;\par
/** SEND_CID - read the card identification information (CID register) */\par
uint8_t const CMD10 = 0X0A;\par
/** STOP_TRANSMISSION - end multiple block read sequence */\par
uint8_t const CMD12 = 0X0C;\par
/** SEND_STATUS - read the card status register */\par
uint8_t const CMD13 = 0X0D;\par
/** READ_SINGLE_BLOCK - read a single data block from the card */\par
uint8_t const CMD17 = 0X11;\par
/** READ_MULTIPLE_BLOCK - read a multiple data blocks from the card */\par
uint8_t const CMD18 = 0X12;\par
/** WRITE_BLOCK - write a single data block to the card */\par
uint8_t const CMD24 = 0X18;\par
/** WRITE_MULTIPLE_BLOCK - write blocks of data until a STOP_TRANSMISSION */\par
uint8_t const CMD25 = 0X19;\par
/** ERASE_WR_BLK_START - sets the address of the first block to be erased */\par
uint8_t const CMD32 = 0X20;\par
/** ERASE_WR_BLK_END - sets the address of the last block of the continuous\par
    range to be erased*/\par
uint8_t const CMD33 = 0X21;\par
/** ERASE - erase all previously selected blocks */\par
uint8_t const CMD38 = 0X26;\par
/** APP_CMD - escape for application specific command */\par
uint8_t const CMD55 = 0X37;\par
/** READ_OCR - read the OCR register of a card */\par
uint8_t const CMD58 = 0X3A;\par
/** CRC_ON_OFF - enable or disable CRC checking */\par
uint8_t const CMD59 = 0X3B;\par
/** SET_WR_BLK_ERASE_COUNT - Set the number of write blocks to be\par
     pre-erased before writing */\par
uint8_t const ACMD23 = 0X17;\par
/** SD_SEND_OP_COMD - Sends host capacity support information and\par
    activates the card's initialization process */\par
uint8_t const ACMD41 = 0X29;\par
//==============================================================================\par
/** status for card in the ready state */\par
uint8_t const R1_READY_STATE = 0X00;\par
/** status for card in the idle state */\par
uint8_t const R1_IDLE_STATE = 0X01;\par
/** status bit for illegal command */\par
uint8_t const R1_ILLEGAL_COMMAND = 0X04;\par
/** start data token for read or write single block*/\par
uint8_t const DATA_START_BLOCK = 0XFE;\par
/** stop token for write multiple blocks*/\par
uint8_t const STOP_TRAN_TOKEN = 0XFD;\par
/** start data token for write multiple blocks*/\par
uint8_t const WRITE_MULTIPLE_TOKEN = 0XFC;\par
/** mask for data response tokens after a write block operation */\par
uint8_t const DATA_RES_MASK = 0X1F;\par
/** write data accepted token */\par
uint8_t const DATA_RES_ACCEPTED = 0X05;\par
//==============================================================================\par
/**\par
 * \\class CID\par
 * \\brief Card IDentification (CID) register.\par
 */\par
typedef struct CID \{\par
  // byte 0\par
  /** Manufacturer ID */\par
  unsigned char mid;\par
  // byte 1-2\par
  /** OEM/Application ID */\par
  char oid[2];\par
  // byte 3-7\par
  /** Product name */\par
  char pnm[5];\par
  // byte 8\par
  /** Product revision least significant digit */\par
  unsigned char prv_m : 4;\par
  /** Product revision most significant digit */\par
  unsigned char prv_n : 4;\par
  // byte 9-12\par
  /** Product serial number */\par
  uint32_t psn;\par
  // byte 13\par
  /** Manufacturing date year low digit */\par
  unsigned char mdt_year_high : 4;\par
  /** not used */\par
  unsigned char reserved : 4;\par
  // byte 14\par
  /** Manufacturing date month */\par
  unsigned char mdt_month : 4;\par
  /** Manufacturing date year low digit */\par
  unsigned char mdt_year_low : 4;\par
  // byte 15\par
  /** not used always 1 */\par
  unsigned char always1 : 1;\par
  /** CRC7 checksum */\par
  unsigned char crc : 7;\par
\} __attribute__((packed)) cid_t;\par
//==============================================================================\par
/**\par
 * \\class CSDV1\par
 * \\brief CSD register for version 1.00 cards .\par
 */\par
typedef struct CSDV1 \{\par
  // byte 0\par
  unsigned char reserved1 : 6;\par
  unsigned char csd_ver : 2;\par
  // byte 1\par
  unsigned char taac;\par
  // byte 2\par
  unsigned char nsac;\par
  // byte 3\par
  unsigned char tran_speed;\par
  // byte 4\par
  unsigned char ccc_high;\par
  // byte 5\par
  unsigned char read_bl_len : 4;\par
  unsigned char ccc_low : 4;\par
  // byte 6\par
  unsigned char c_size_high : 2;\par
  unsigned char reserved2 : 2;\par
  unsigned char dsr_imp : 1;\par
  unsigned char read_blk_misalign : 1;\par
  unsigned char write_blk_misalign : 1;\par
  unsigned char read_bl_partial : 1;\par
  // byte 7\par
  unsigned char c_size_mid;\par
  // byte 8\par
  unsigned char vdd_r_curr_max : 3;\par
  unsigned char vdd_r_curr_min : 3;\par
  unsigned char c_size_low : 2;\par
  // byte 9\par
  unsigned char c_size_mult_high : 2;\par
  unsigned char vdd_w_cur_max : 3;\par
  unsigned char vdd_w_curr_min : 3;\par
  // byte 10\par
  unsigned char sector_size_high : 6;\par
  unsigned char erase_blk_en : 1;\par
  unsigned char c_size_mult_low : 1;\par
  // byte 11\par
  unsigned char wp_grp_size : 7;\par
  unsigned char sector_size_low : 1;\par
  // byte 12\par
  unsigned char write_bl_len_high : 2;\par
  unsigned char r2w_factor : 3;\par
  unsigned char reserved3 : 2;\par
  unsigned char wp_grp_enable : 1;\par
  // byte 13\par
  unsigned char reserved4 : 5;\par
  unsigned char write_partial : 1;\par
  unsigned char write_bl_len_low : 2;\par
  // byte 14\par
  unsigned char reserved5: 2;\par
  unsigned char file_format : 2;\par
  unsigned char tmp_write_protect : 1;\par
  unsigned char perm_write_protect : 1;\par
  unsigned char copy : 1;\par
  /** Indicates the file format on the card */\par
  unsigned char file_format_grp : 1;\par
  // byte 15\par
  unsigned char always1 : 1;\par
  unsigned char crc : 7;\par
\} __attribute__((packed)) csd1_t;\par
//==============================================================================\par
/**\par
 * \\class CSDV2\par
 * \\brief CSD register for version 2.00 cards.\par
 */\par
typedef struct CSDV2 \{\par
  // byte 0\par
  unsigned char reserved1 : 6;\par
  unsigned char csd_ver : 2;\par
  // byte 1\par
  /** fixed to 0X0E */\par
  unsigned char taac;\par
  // byte 2\par
  /** fixed to 0 */\par
  unsigned char nsac;\par
  // byte 3\par
  unsigned char tran_speed;\par
  // byte 4\par
  unsigned char ccc_high;\par
  // byte 5\par
  /** This field is fixed to 9h, which indicates READ_BL_LEN=512 Byte */\par
  unsigned char read_bl_len : 4;\par
  unsigned char ccc_low : 4;\par
  // byte 6\par
  /** not used */\par
  unsigned char reserved2 : 4;\par
  unsigned char dsr_imp : 1;\par
  /** fixed to 0 */\par
  unsigned char read_blk_misalign : 1;\par
  /** fixed to 0 */\par
  unsigned char write_blk_misalign : 1;\par
  /** fixed to 0 - no partial read */\par
  unsigned char read_bl_partial : 1;\par
  // byte 7\par
  /** high part of card size */\par
  unsigned char c_size_high : 6;\par
  /** not used */\par
  unsigned char reserved3 : 2;\par
  // byte 8\par
  /** middle part of card size */\par
  unsigned char c_size_mid;\par
  // byte 9\par
  /** low part of card size */\par
  unsigned char c_size_low;\par
  // byte 10\par
  /** sector size is fixed at 64 KB */\par
  unsigned char sector_size_high : 6;\par
  /** fixed to 1 - erase single is supported */\par
  unsigned char erase_blk_en : 1;\par
  /** not used */\par
  unsigned char reserved4 : 1;\par
  // byte 11\par
  unsigned char wp_grp_size : 7;\par
  /** sector size is fixed at 64 KB */\par
  unsigned char sector_size_low : 1;\par
  // byte 12\par
  /** write_bl_len fixed for 512 byte blocks */\par
  unsigned char write_bl_len_high : 2;\par
  /** fixed value of 2 */\par
  unsigned char r2w_factor : 3;\par
  /** not used */\par
  unsigned char reserved5 : 2;\par
  /** fixed value of 0 - no write protect groups */\par
  unsigned char wp_grp_enable : 1;\par
  // byte 13\par
  unsigned char reserved6 : 5;\par
  /** always zero - no partial block read*/\par
  unsigned char write_partial : 1;\par
  /** write_bl_len fixed for 512 byte blocks */\par
  unsigned char write_bl_len_low : 2;\par
  // byte 14\par
  unsigned char reserved7: 2;\par
  /** Do not use always 0 */\par
  unsigned char file_format : 2;\par
  unsigned char tmp_write_protect : 1;\par
  unsigned char perm_write_protect : 1;\par
  unsigned char copy : 1;\par
  /** Do not use always 0 */\par
  unsigned char file_format_grp : 1;\par
  // byte 15\par
  /** not used always 1 */\par
  unsigned char always1 : 1;\par
  /** checksum */\par
  unsigned char crc : 7;\par
\} __attribute__((packed)) csd2_t;\par
//==============================================================================\par
/**\par
 * \\class csd_t\par
 * \\brief Union of old and new style CSD register.\par
 */\par
union csd_t \{\par
  csd1_t v1;\par
  csd2_t v2;\par
\};\par
#endif  // SdInfo_h\par
\par
\par
///END OF LIB_SD_FAT\line #include "lib_end.h"\line @END\par
\par
\{\par
 stop\par
\};\par
\par
}
 